---
title: "DOGE_Coin"
author: "Shivam Patel"
date: "3/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load Library}
library(httr)
library(forecast)
library(xts)
```


```{r}
# API KEY: 0YR02HPT5Z0LVCHN
# getFXData <- function(from_currency, to_currency) {
#   # API KEY
#   avKey <- "0YR02HPT5Z0LVCHN"
#   baseLink <- "https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE"
#   
#   avLinkGenerator <- paste(baseLink, 
#                            "&from_currency=", from_currency, "&to_currency", to_currency, "&interval=60min", "&datatype=csv",
#                            "&apikey=", avKey, sep = "")
#   
#   avRequest <- GET(avLinkGenerator)
#   avParsed <- read.delim(text = content(avRequest, as = "text"), sep = ",")
#   avParsed$timestamp <- as.Date(avParsed$timestamp)
#   return(avParsed)
# }
# 
# silverSpot <- getFXData("USD", "XAG")
# 
# testsilver <- GET("https://www.alphavantage.co/query?function=FX_INTRADAY&datatype=csv&from_symbol=USD&to_symbol=XAG&interval=60min&apikey=0YR02HPT5Z0LVCHN")
# 
# silverparsed <- read.delim(text = content(testsilver, as = "text"), sep = ",")
# doge_test <- GET("https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&symbol=DOGE&market=CNY&datatype=csv&apikey=0YR02HPT5Z0LVCHN")
# dogeparsed <- read.delim(text = content(doge_test, as = "text"), sep = ",")
#save(dogeparsed, file = "./data/DOGE.Rdata")
# only uncomment to update the data to the most recent
# Going to use Close Price, USD.
```

# BEGIN PROJECT

```{r}
load(file = "./data/DOGE.Rdata")
```

```{r Explore Data}
head(dogeparsed)
dogeparsed$timestamp <- as.Date(dogeparsed$timestamp)
str(dogeparsed)
```
```{r Data Cleaning}
dogeparsed <- dogeparsed[c(1,9)]
doge_xts <- xts(dogeparsed[-1], order.by = dogeparsed$timestamp, frequency = 1)
doge_xts <- doge_xts[500:615]
colnames(doge_xts) <- c("close")
```

```{r Plotting}
autoplot(doge_xts[-1], main = "Dogecoin", ylab = "USD", xlab = "Time")
```

```{r Transformation}
BoxCox.lambda(doge_xts)
# -.5 value returned so there is a need for some transformation
# lets run it under the boxcox transformation auto and by manually setting the lamba value
plot(doge_xts)
plot(BoxCox(doge_xts,lambda="auto"))
plot(BoxCox(doge_xts,lambda = -.25))
# Let's take the auto transformation data and use that
doge_transformed <- BoxCox(doge_xts, lambda = "auto")
```

```{r Explore the ACF before and after transformation}
Acf(doge_xts)
Acf(doge_transformed[,1])
```

Still not great, lets try differencing

```{r}
# INSERT MICHAEL CODE
```


```{r Splitting the data}
doge_train <- doge_xts[1:92]
doge_test <- doge_xts[93:116]

doge_ts <- ts(doge_xts)
doge_train <- ts(doge_train)
```

Let's explore some simple forecasting methods

```{r Simple Forecasting Methods}
mean_doge <- meanf(doge_train, h = 24)
naive_doge <- naive(doge_train, h = 24)
snaive_doge <- snaive(doge_train, h = 24)
drift_doge <- rwf(doge_train, h = 24, drift = TRUE)

autoplot(window(doge_ts, end = 92)) +
  autolayer(window(doge_ts, start = 92), series = "Test Data") +
  autolayer(mean_doge, series = "Average Method", PI = FALSE) +
  autolayer(naive_doge, series = "Naive Method", PI = FALSE) +
  autolayer(snaive_doge, series = "Seasonal Naive Method", PI = FALSE) +
  autolayer(drift_doge, series = "Drift Method", PI = FALSE)
# Seasonal Naive and Naive are the same here
```

```{r Measure Accuracy of Simple Forecasting Methods}
print("Mean")
accuracy(mean_doge, window(doge_ts, start = 92))
print("Naive")
accuracy(naive_doge, window(doge_ts, start = 92))
print("Seasonal Naive")
accuracy(snaive_doge, window(doge_ts, start = 92))
print("Drift Method")
accuracy(drift_doge, window(doge_ts, start = 92))
```











# ```{r Exploration}
# autoplot(doge_ts[-1], main = "Dogecoin", ylab = "USD", xlab = "Time")
# autoplot(doge_xts[-1], main = "Dogecoin", ylab = "USD", xlab = "Time")
# snaive(doge_xts)
# hw(doge_ts)
# rwf(doge_xts)
# 
# vis <- window(doge_ts, end=c(2020,1)) #training data
# vis2 <- window(doge_ts, start=c(2020, 1))# Test data
# library(tsstudio)
# test <- xts_to_ts(doge_xts, frequency = NULL, start = NULL)
# 
# plot(meanf(beer1, h=20), plot.conf=FALSE) #Forecasts produced by Average of Past Values method
#     lines(naive(beer1, h=20)$mean, col="red") #Forecasts produced by Naive method
#     lines(snaive(beer1, h=20)$mean, col="green") #Forcasts produced by Seasonal naive method
#     lines(rwf(beer1, h=20, drift=TRUE)$mean, col="pink") #Forecasts produced by Drift method
#     lines(window(ausbeer,start=2004)) #Actual data
# 
# train = doge_xts[,1][1:150]
# test = doge_xts[,1][151:164]
# 
# adf.test(train[,1]) #p-value < 0.01: the time series is stationary
# Acf(train[,1]) #indicates MA(3) model
# Pacf(train[,1])
# 
# fit <- Arima(train[,1],order = c(0,0,3))
# summary(fit)
# 
# tsdisplay(fit$residuals) #Check the residuals
# Box.test(fit$residuals,lag=15, fitdf=3, type='Ljung') #fitdf is because it was MA(3)
# 
# plot(forecast(fit,h=10),include=80)
# 
# fit_ETS <- ets(doge_xts)
# 
# plot(doge_xts)
# fit <- ets(doge_xts)
# fcast1 <-forecast(fit, h=20)
# summary(fit)
# plot(fit)
# accuracy(fit)
# accuracy(fcast1$fitted, doge_xts)
# plot(forecast(fit,level=c(50,80,95)))
# plot(forecast(fit,fan =TRUE))
# ```
# 
# ```{r}
# 
# plot(doge_xts)
# plot(BoxCox(doge_xts,lambda=1/2))## Transformations with lamda = 1/2
# plot(BoxCox(doge_xts,lambda=0))## Transformations with lamda = 0, which is natural logarithm
# plot(BoxCox(doge_xts,lambda=-1))## Transformations with lamda = -1
# 
# plot(BoxCox(doge_xts,lambda=0))
# fit <- snaive(doge_xts, lambda=0)
# plot(fit)
# plot(fit, include=120)
# 
# BoxCox.lambda(doge_xts) #mathematically optimal lambda, lambda = 0.2654076
# plot(BoxCox(doge_xts,lambda=BoxCox.lambda(doge_xts)))
# 
# ndiffs(doge_xts)
# nsdiffs(log(doge_xts))
# 
# plot(doge_xts)
# # No obvious need for a transformation
# tsdisplay(diff(doge_xts))
# 
# fit2 <- auto.arima(doge_xts)
# summary(fit2)
# # Over-ride choice of differencing, and only use one difference
# fit3 <- auto.arima(doge_xts, d=2)
# summary(fit3)
# 
# ```
